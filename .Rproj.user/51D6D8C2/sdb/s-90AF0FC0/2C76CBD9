{
    "contents" : "## The Costs, Both Economic and Human, of Weather Events in the US\nHere is a synopsis. Add several sentences.\n\n### Data Processing\nI got the data from here. Quick description. \n\n```{r, cache=TRUE}\nstormdata <- read.csv(bzfile(\"repdata-data-StormData.csv.bz2\"))\n```\n\nLet's look at the variable names.\n```{r}\nnames(stormdata)\n```\n\nFor this analysis, we care most about events and their human and economic costs across the United States. Let's take a look at those variables. \n\nFirst, the events.\n```{r}\nunique(stormdata$EVTYPE)[1:5]\n```\n\nNearly 1000 different event types and those types are as expected. Should we aggregate similar types?\n\nNext, the human costs. There are two variables that matter to us. \n```{r}\nstr(stormdata$FATALITIES)\nsummary(stormdata$FATALITIES)\nstr(stormdata$INJURIES)\nsummary(stormdata$INJURIES)\n```\n\nNo surprises there. \n\nWe will create a new variable called `CASUALTIES` which we define as the sum of `INJURIES` and 10 * `FATALITIES`. In estimating human cost, a single fatality should count much more than an injury.\n```{r}\nsuppressMessages(library(dplyr))\n#Start creating a subset of stormdata for specific analysis\nstormdatatidy <- mutate(stormdata, CASUALTIES = FATALITIES * 10 + INJURIES)\nsummary(stormdatatidy$CASUALTIES)\n```\n\nLet's turn our attention to economic costs. Both property and crop damage count are economic costs.\n\nFirst, property damage. Curiously, there are two variables which may matter.\n```{r}\nstr(stormdata$PROPDMG)\nsummary(stormdata$PROPDMG)\nstr(stormdata$PROPDMGEXP)\nsummary(stormdata$PROPDMGEXP)\n```\n\n`PROPDMG` is a numeric vector as expected although the numbers seem low. Surprisingly, `PROPDMGEXP` is a 19 level factor variable. Let's take a closer look.\n```{r}\nsummarize(group_by(stormdata, PROPDMGEXP), count = n())\n```\n\nAlmost all observations are either `K`, `M` or `EMPTY`. It's reasonable to assume that `K` stands for thousands, `M` for millions and `EMPTY` for small (< $1000) amounts of damage or none at all. Let's take a closer look. \n```{r}\nsummarize(group_by(stormdata, PROPDMGEXP), count = format(n(), big.mark = \",\"), dollars = format(sum(PROPDMG), big.mark = \",\", digits = \"0\", scientific = FALSE))\n```\n\nGiven how large the `K`, `M` and `EMPTY` are in terms of dollars, we can safely ignore the remaining 16 factors as transcription errors. \n\nIn our `stormdatatidy` set, let's create a new variable based on `PROPDMG` so that we have the damage in consistent dollars. Then, we'll keep only the observations we the three factors we care about.\n```{r}\n#Chaining would be nice to use here if I had the time.\nstormdatatidy <- mutate(stormdatatidy, MULT = ifelse(PROPDMGEXP == \"\", 1, ifelse(PROPDMGEXP == \"K\", 1000, ifelse(PROPDMGEXP == \"M\", 1000000, 0))))\nstormdatatidy <- mutate(stormdatatidy, propdamage = MULT * PROPDMG)\nstormdatatidy <- filter(stormdatatidy, PROPDMGEXP == \"\" | PROPDMGEXP == \"K\" | PROPDMGEXP == \"M\")\ndim(stormdata)\ndim(stormdatatidy)\n```\n\nNow, we turn our attention to crop damage. Like property damage, there are two variables involved: `CROPDMG` and `CROPDMGEXP`. Let's use the same approach. \n```{r}\nsummarize(group_by(stormdata, CROPDMGEXP), count = format(n(), big.mark = \",\"), dollars = format(sum(CROPDMG), big.mark = \",\", digits = \"0\", scientific = FALSE))\n```\n\nWe see `K`, `M` and `EMPTY` dominate in the case, too. Therefore we will use the same approach as with property damage: create a new varible with consistent dollars and discard the presumed transcription errors. \n```{r}\nstormdatatidy <- stormdatatidy %>%\n        mutate(MULT = ifelse(CROPDMGEXP == \"\", 1, \n            ifelse(CROPDMGEXP == \"K\", 1000, \n            ifelse(CROPDMGEXP == \"M\", 1000000, 0)))) %>%\n        mutate(cropdamage = MULT * PROPDMG) %>%\n        filter(CROPDMGEXP == \"\" | CROPDMGEXP == \"K\" | CROPDMGEXP == \"M\")\ndim(stormdata)\ndim(stormdatatidy)\n```\n\nNow we'll sum `cropdamage` and `propdamage` to create overall `econdamage`.\n```{r}\nstormdatatidy <- stormdatatidy %>%\n        mutate(econdamage = cropdamage + propdamage)\nsummary(stormdatatidy$econdamage)\n```\n\nNow, a final cleanup to capture just the variables we want.\n```{r}\nstormdatatidy <- select(stormdatatidy, EVTYPE, casualties = CASUALTIES, econdamage)\ndim(stormdata)\ndim(stormdatatidy)\n```\n\nLooks like we're ready to do some analysis. (Finally.)\n```{r}\nsummary(stormdatatidy)\n```\n### Results\nWe will create with a simple summary table as the backbone of our analysis.\n```{r}\nsumtbl <- summarize(group_by(stormdatatidy, EVTYPE), casualties = sum(casualties), damage = sum(econdamage))\n```\n\nNot surprisingly, there's a strong correlation between damage and casualties.\n```{r}\nsuppressWarnings(library(ggplot2))\nggplot(sumtbl, aes(log10(damage), log10(casualties))) + geom_point()\n#With more time, draw the linear regression\n```\n\nLet's see which events create the most casualties.\n```{r}\narrange(sumtbl, desc(casualties))\n```\n\nAnd the most economic damage.\n```{r}\narrange(sumtbl, desc(damage))\n```\n\nLet's see which `EVTYPE` are in the top 20 for both casualties and damage.\n```{r}\nc20 <- arrange(sumtbl, desc(casualties))[1:20,1]\nd20 <- arrange(sumtbl, desc(damage))[1:20,1]\ni <- intersect(c20, d20)\ni\n```\n\nHere's the best summary for a time-strapped government body.\n```{r}\nsuppressWarnings(library(knitr))\nkable(\n        sumtbl %>%\n        #Pick the events that are top 20 in both casualties and damage\n        filter(EVTYPE %in% i$EVTYPE) %>%\n        #Sort by casualties\n        arrange(desc(casualties))\n        )\n```\n\nLooks like governments should have responses (snow plows) as well as preventative measures (e.g. building codes, warning systems) to minimize casualties and economic damange from extreme weather.",
    "created" : 1429671672560.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2998539637",
    "id" : "2C76CBD9",
    "lastKnownWriteTime" : 1430077505,
    "path" : "~/RepData_PeerAssessment2/RepData_PA2.Rmd",
    "project_path" : "RepData_PA2.Rmd",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_markdown"
}